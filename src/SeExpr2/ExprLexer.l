/*
* Copyright Disney Enterprises, Inc.  All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License
* and the following modification to it: Section 6 Trademarks.
* deleted and replaced with:
*
* 6. Trademarks. This License does not grant permission to use the
* trade names, trademarks, service marks, or product names of the
* Licensor and its affiliates, except as required for reproducing
* the content of the NOTICE file.
*
* You may obtain a copy of the License at
* http://www.apache.org/licenses/LICENSE-2.0
*/

%{
#ifndef MAKEDEPEND
#include <ctype.h>
#include <string.h>
#include <string>
#include <math.h>
#include <vector>
#endif

// If c++11 don't use register designator, lex and yacc need to go...
#if __cplusplus > 199711L
#define register          // Deprecated in C++11.
#endif                    // #if __cplusplus > 199711L

#include "Platform.h"
#include "ExprNode.h"
#include "Expression.h"
#include "Mutex.h"
#include "ExprParseAction.h"
#include "ExprParserLex.h"
#include "ExprParser.tab.h"

// SeExpr2lex is generated by flex, as YY_DECL
#define YY_DECL int SeExpr2lex(YYSTYPE* yylval_param, YYLTYPE* yylloc, void* yyscanner, SeExpr2::ParseState *state, SeExpr2::ParseData*) 
#define YYLEX_PARAM &yylval_param, &yylloc

#define YY_USER_ACTION { \
  yylloc->first_line = yylloc->last_line = yylineno; \
  yylloc->first_column = state->yycolno; \
  yylloc->last_column = state->yycolno+yyleng-1; \
  state->yycolno += yyleng;\
}

#ifdef SEEXPR_WIN32
#define YY_NO_UNISTD_H
#define YY_SKIP_YYWRAP
#endif

#ifndef MAKEDEPEND
#include "ExprParser.tab.h"
#endif

int yyparse(void* yyscanner, SeExpr2::ParseState *state, SeExpr2::ParseData *parseData);

%}

%option reentrant
%option extra-type = "SeExpr2::ParseState *"
%option bison-bridge
/* Don't generate yywrap since everything is in one string */
%option noyywrap 
/* Don't generate unput since it's unused and gcc complains... */
%option nounput
%option yylineno

D                       [0-9]
E                       [Ee][+-]?{D}+
REAL                    {D}+({E})?|{D}*"."{D}+({E})?|{D}+"."{D}*({E})?
IDENT                   [a-zA-Z_][a-zA-Z0-9_.]*

%%
BEGIN(INITIAL);

extern                  { return EXTERN; }
def                     { return DEF; }
FLOAT                   { return FLOATPOINT; }
STRING                  { return STRING; }
CONSTANT                { return LIFETIME_CONSTANT; }
UNIFORM                 { return LIFETIME_UNIFORM; }
VARYING                 { return LIFETIME_VARYING; }
ERROR                   { return LIFETIME_ERROR; }

if                      { return IF; }
else                    { return ELSE; }

"||"                    { return OR; }
"&&"                    { return AND; }
"=="                    { return EQ; }
"!="                    { return NE; }
"<="                    { return SEEXPR_LE; }
">="                    { return SEEXPR_GE; }
"->"                    { return ARROW; }
"+="                    { return AddEq; }
"-="                    { return SubEq; }
"*="                    { return MultEq; }
"/="                    { return DivEq; }
"%="                    { return ModEq; }
"^="                    { return ExpEq; }

PI              { yylval->d = M_PI; return NUMBER; }
E               { yylval->d = M_E; return NUMBER; }
linear          { yylval->d = 0; return NUMBER; }
smooth          { yylval->d = 1; return NUMBER; }
gaussian        { yylval->d = 2; return NUMBER; }
box             { yylval->d = 3; return NUMBER; }

{REAL}          { yylval->d = atof(yytext); return NUMBER; }

\"(\\\"|[^"\n])*\"  { /* match quoted string, allow embedded quote, \" */
                      yylval->s = strdup(&yytext[1]);
                      yylval->s[strlen(yylval->s)-1] = '\0';
                      yycolumn = 1;
                      return STR; }
\'(\\\'|[^'\n])*\'  { /* match quoted string, allow embedded quote, \' */
                      yylval->s = strdup(&yytext[1]);
                      yylval->s[strlen(yylval->s)-1] = '\0';
                      yycolumn = 1;
                      return STR; }
${IDENT}            { yylval->s = strdup(&yytext[1]); return VAR; }
${IDENT}"::"{IDENT} { yylval->s = strdup(&yytext[1]); return VAR; }
{IDENT}             { yylval->s = strdup(yytext); return NAME; }

"\\n"               { yycolumn = 1; }
"\\t"           /* ignore quoted tab */;
[ \t]           /* ignore whitespace */;
\n                  { yycolumn = 1; }

\#([^\\\n]|\\[^n\n])*   { /* match comment */
                          int startPos=YY_CURRENT_BUFFER->yy_bs_column;
                          int endPos=startPos+strlen(&yytext[1])+1;
                          yyextra->comments->push_back(std::pair<int,int>(startPos,endPos));}

<*>.                    { return yytext[0]; }

%%


// Gets the current token, replaces yytext
char* getText(yyscan_t scanner) 
{
    return yyget_text(scanner);
}

namespace SeExpr2 {

/* ExprParseAction - This is our entrypoint from the rest of the expr library.
   A string is passed in and a parse tree is returned.  If the tree is null,
   an error string is returned.  Any flags set during parsing are passed
   along.
 */

bool ExprParseAction(SeExpr2::ExprNode*& parseTree,
                     std::string& error, int&, int&,
                     std::vector<std::pair<int,int> >& comments,
                     const SeExpr2::Expression* expr, const char* exprStr, bool)
{
    // set up parse data
    SeExpr2::ParseState state(&comments);
    SeExpr2::ParseData *parseData = new ParseData();
    parseData->Expr = expr;
    parseData->ParseStr = exprStr;
    parseData->ParseResult = nullptr;

    yyscan_t scanner(nullptr);
    if (yylex_init_extra(&state, &scanner)!=0)
        std::cerr << "Parse error in lexer\n";

    // scan and parse expression string
    yy_buffer_state* buffer = yy_scan_string(exprStr, scanner);
    yyset_lineno(0, scanner);
    int resultCode = SeExpr2parse(scanner, &state, parseData);
    yy_delete_buffer(buffer, scanner);

    if (resultCode == 0) { // success
        error = "";
        parseTree = parseData->ParseResult;
    } else {               // failure
        error = parseData->ParseError;
        parseTree = 0;

        // gather list of nodes with no parent
        std::vector<SeExpr2::ExprNode*> delnodes;
        std::vector<SeExpr2::ExprNode*>::iterator iter;
        for (iter = parseData->ParseNodes.begin(); iter != parseData->ParseNodes.end(); iter++)
            if (!(*iter)->parent()) { delnodes.push_back(*iter); }

        // now delete them (they will delete their own children)
        for (iter = delnodes.begin(); iter != delnodes.end(); iter++)
            delete *iter;
    }
    parseData->ParseNodes.clear();
    delete parseData;
    yylex_destroy(scanner);

    return parseTree != 0;
}
}
